[
  {
    "id": 1,
    "title": "Two Sum",
    "description": "Given an array of integers  nums  and an integer  target , return  indices of the two numbers such that they add up to  target .  You may assume that each input would have  exactly  one solution , and you may not use the  same  element twice.  You can return the answer in any order.",
    "examples": [
      "Example 1:  Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].   ",
      "Example 2:  Input: nums = [3,2,4], target = 6 Output: [1,2]   ",
      "Example 3:  Input: nums = [3,3], target = 6 Output: [0,1]     "
    ],
    "constraints": [
      "2 <= nums.length <= 104",
      "-109 <= nums[i] <= 109",
      "-109 <= target <= 109",
      "Only one valid answer exists."
    ],
    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List\n[int]:",
    "testCases": [
      {
        "inputs": {
          "nums": [2, 7, 11, 15],
          "target": 9
        },
        "expectedOutput": [0, 1]
      },
      {
        "inputs": {
          "nums": [3, 2, 4],
          "target": 6
        },
        "expectedOutput": [1, 2]
      },
      {
        "inputs": {
          "nums": [3, 3],
          "target": 6
        },
        "expectedOutput": [0, 1]
      }
    ]
  },
  {
    "id": 2,
    "title": "Add Two Numbers",
    "description": "You are given two  non-empty  linked lists representing two non-negative integers. The digits are stored in  reverse order , and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.  You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "examples": [
      "Example 1:  Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807.   ",
      "Example 2:  Input: l1 = [0], l2 = [0] Output: [0]   ",
      "Example 3:  Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1]     "
    ],
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ],
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: \nOptional[ListNode]) -&gt; Optional[ListNode]:",
    "testCases": [
      {
        "inputs": {
          "l1": [2, 4, 3],
          "l2": [5, 6, 4]
        },
        "expectedOutput": [7, 0, 8]
      },
      {
        "inputs": {
          "l1": [0],
          "l2": [0]
        },
        "expectedOutput": [0]
      },
      {
        "inputs": {
          "l1": [9, 9, 9, 9, 9, 9, 9],
          "l2": [9, 9, 9, 9]
        },
        "expectedOutput": [8, 9, 9, 9, 0, 0, 0, 1]
      }
    ]
  },
  {
    "id": 3,
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string  s , find the length of the  longest   substring  without repeating characters.",
    "examples": [
      "Example 1:  Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3.   ",
      "Example 2:  Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1.   ",
      "Example 3:  Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.     "
    ],
    "constraints": [
      "0 <= s.length <= 5 * 104",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:",
    "testCases": [
      {
        "inputs": {
          "s": "abcabcbb"
        },
        "expectedOutput": 3
      },
      {
        "inputs": {
          "s": "bbbbb"
        },
        "expectedOutput": 1
      },
      {
        "inputs": {
          "s": "pwwkew"
        },
        "expectedOutput": 3
      }
    ]
  },
  {
    "id": 4,
    "title": "Median Of Two Sorted Arrays",
    "description": "Given two sorted arrays  nums1  and  nums2  of size  m  and  n  respectively, return  the median  of the two sorted arrays.  The overall run time complexity should be  O(log (m+n)) .",
    "examples": [
      "Example 1:  Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2.   ",
      "Example 2:  Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.     "
    ],
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-106 <= nums1[i], nums2[i] <= 106"
    ],
    "code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], \nnums2: List[int]) -&gt; float:",
    "testCases": [
      {
        "inputs": {
          "nums1": [1, 3],
          "nums2": [2]
        },
        "expectedOutput": 2.0
      },
      {
        "inputs": {
          "nums1": [1, 2],
          "nums2": [3, 4]
        },
        "expectedOutput": 2.5
      }
    ]
  }
]
